<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SRT Subtitle Translator Pro</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;700&family=Orbitron:wght@400;700&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    :root {
      --bg:#0b0c0f; --panel:rgba(18,18,18,.85); --ink:#e7e7e7; --muted:#9aa0a6;
      --neon:#ff6c00; --neonSoft:rgba(255,108,0,.5); --accent:#00ffaa;
      --err:#ff375f; --ok:#00ff7b; --warn:#ffd60a; --border:rgba(255,108,0,.35);
      --radius:12px; --shadow:0 0 18px var(--neonSoft), inset 0 0 0 1px rgba(255,255,255,.03);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:"Vazirmatn",system-ui,sans-serif;background:var(--bg);color:var(--ink);display:flex;flex-direction:column;min-height:100vh;padding:1rem}
    header{position:sticky;top:0;background:var(--panel);padding:1rem;text-align:center;border-bottom:1px solid var(--border);z-index:10}
    .app{flex:1;width:100%;max-width:1280px;display:grid;grid-template-columns:360px 1fr;gap:1rem;margin:1rem auto}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);backdrop-filter:blur(10px);box-shadow:var(--shadow);padding:1.5rem;display:flex;flex-direction:column;gap:1rem}
    h1{margin:0;font:700 1.5rem/1.2 "Orbitron",sans-serif;color:var(--neon);text-shadow:0 0 6px var(--neonSoft)}
    .subtitle{margin-top:-0.5rem;color:var(--muted);font-size:.875rem}
    .drop{border:2px dashed var(--border);border-radius:var(--radius);padding:1.5rem;text-align:center;cursor:pointer;min-height:120px;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:.5rem;transition:border-color .2s,box-shadow .2s}
    .drop:hover,.drop.drag{border-color:var(--neon);box-shadow:0 0 16px var(--neonSoft)}
    .hstack{display:flex;gap:.75rem;align-items:center}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:.75rem}
    label{font-size:.875rem;color:var(--muted)}
    select,input[type=text],input[type=number]{width:100%;padding:.75rem;border-radius:8px;border:1px solid var(--border);background:rgba(0,0,0,.35);color:var(--ink);font-family:inherit;font-size:.875rem}
    textarea{min-height:80px;resize:vertical}
    .btn{user-select:none;border:none;border-radius:8px;padding:.75rem 1rem;font:700 .875rem "Orbitron",sans-serif;cursor:pointer;transition:transform .2s,box-shadow .2s}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn-primary{background:linear-gradient(135deg,var(--neon),#c75800);color:#fff;box-shadow:0 8px 20px rgba(0,0,0,.35)}
    .btn-primary:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 0 18px var(--neonSoft)}
    .btn-success{background:linear-gradient(135deg,#00a86b,#007b4b);color:#fff}
    .btn-ghost{background:transparent;border:1px dashed var(--border);color:var(--ink)}
    .kpi{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:.5rem;border:1px solid var(--border);border-radius:var(--radius);overflow:hidden}
    .kpi div{padding:.75rem;background:#050607;display:grid;gap:.25rem;text-align:center}
    .kpi .key{font-size:.75rem;color:var(--muted)}
    .kpi .val{font:700 .875rem "Roboto Mono",monospace;color:var(--neon)}
    .progress-bar{height:4px;background:var(--neon);width:0;transition:width .3s ease-out}
    .preview{display:grid;grid-template-columns:1fr;gap:.75rem}
    .pane{border:1px solid var(--border);border-radius:var(--radius);overflow:hidden}
    .pane h3{margin:0;padding:.75rem;border-bottom:1px solid var(--border);font:700 .875rem "Orbitron",sans-serif;color:var(--neon)}
    .pane .body{padding:.75rem;max-height:200px;overflow:auto;direction:ltr;text-align:left;font:.875rem "Roboto Mono",monospace}
    .log{max-height:150px;overflow:auto;border:1px solid var(--border);border-radius:var(--radius);padding:.75rem;background:rgba(0,0,0,.35);font:.75rem/1.5 "Roboto Mono",monospace}
    .log p{margin:0 0 .25rem}
    .ok{color:var(--ok)} .err{color:var(--err)} .info{color:#87cefa} .warn{color:var(--warn)}
    footer{position:sticky;bottom:0;background:var(--panel);padding:1rem;text-align:center;font-size:.75rem;color:var(--muted);border-top:1px solid var(--border)}
    .hidden{display:none}
    .fileName{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;direction:ltr;text-align:left}
    @media(max-width:900px){
      .app{grid-template-columns:1fr}
      .preview{grid-template-columns:1fr}
      header,footer{position:static}
    }
  </style>
</head>
<body>
<header>
  <h1>srtDICKâ˜¬SHÎNeri</h1>
  <div class="subtitle">Ø¯ÛŒÚ©â€ŒØ´ÛŒÙ†Ù€Ø±ÛŒ Ø§ÙˆÙ„ÛŒÙ† Ù…ØªØ±Ø¬Ù… Ø§Ø³ØªØ§ØªÛŒÚ© Ø³Ø§Ø¨â€ŒØªØ§ÛŒØªÙ„</div>
</header>

<main class="app" id="app">
  <section class="card">
    <div class="drop" id="drop">
      <div>ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ ÛŒØ§ ZIP Ø±Ø§ Ø±Ù‡Ø§ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</div>
      <div class="badge">ğŸ—’ï¸SRT ğŸ“™ VTT ğŸ“‘ ASS ğŸ—„ï¸ ZIPğŸ—‚ï¸</div>
      <input id="file" type="file" accept=".srt,.vtt,.ass,.zip" multiple class="hidden">
    </div>
    <div class="hstack">
      <input type="text" id="urlInput" placeholder="ÛŒØ§ Ù„ÛŒÙ†Ú© Ù…Ø³ØªÙ‚ÛŒÙ… ÙØ§ÛŒÙ„ Ø²ÛŒØ±Ù†ÙˆÛŒØ³" style="flex:1">
      <button class="btn btn-ghost" id="btnLoadUrl">Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ</button>
    </div>
    <div class="grid2">
      <div>
        <label>Ø²Ø¨Ø§Ù† Ø²ÛŒØ±Ù†ÙˆÛŒØ³ ÙˆØ±ÙˆØ¯ÛŒ </label>
        <select id="src">
          <option value="auto">ØªØ´Ø®ÛŒØµ Ø®ÙˆØ¯Ú©Ø§Ø±</option>
          <option value="en">English</option><option value="de">German</option><option value="fr">French</option>
          <option value="es">Spanish</option><option value="it">Italian</option><option value="ru">Russian</option>
          <option value="ja">Japanese</option><option value="ko">Korean</option><option value="zh">Chinese</option>
          <option value="ar">Ø¹Ø±Ø¨ÛŒ</option>
        </select>
      </div>
      <div>
        <label>Ø²Ø¨Ø§Ù† Ø®Ø±ÙˆØ¬ÛŒ</label>
        <select id="tgt">
          <option value="fa">ÙØ§Ø±Ø³ÛŒ</option>
          <option value="en">English</option><option value="de">German</option><option value="fr">French</option>
          <option value="es">Spanish</option><option value="it">Italian</option><option value="ru">Russian</option>
          <option value="ja">Japanese</option><option value="ko">Korean</option><option value="zh">Chinese</option>
          <option value="ar">Ø¹Ø±Ø¨ÛŒ</option>
        </select>
      </div>
    </div>
    <div id="advancedSettings" class="card">
      <h3>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡</h3>
      <label>ØªØ±Ø¬Ù…Ú© Ø³ÙØ§Ø±Ø´ÛŒ (from => to)</label>
      <textarea id="glossary" placeholder="war => Ø¬Ù†Ú¯&#10;AI => Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ"></textarea>
      <div class="grid2">
        <div>
          <label>Ø³Ø¨Ú© ØªØ±Ø¬Ù…Ù‡</label>
          <select id="translationStyle">
            <option value="colloquial">Ù…Ø­Ø§ÙˆØ±Ù‡</option>
            <option value="academic">Ø¢Ú©Ø§Ø¯Ù…ÛŒÚ©</option>
            <option value="adult">Ø¨Ø²Ø±Ú¯Ø³Ø§Ù„</option>
          </select>
        </div>
        <div class="hstack">
          <input type="checkbox" id="filterProfanity">
          <label for="filterProfanity">ÙÛŒÙ„ØªØ± Ø§Ù„ÙØ§Ø¸ Ø±Ú©ÛŒÚ©</label>
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>ØªØ§Ø®ÛŒØ± (Ø«Ø§Ù†ÛŒÙ‡)</label>
          <input type="number" id="delay" min="0" step="0.1" value="0" placeholder="0.0">
        </div>
        <div>
          <label>ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ØªÙ†</label>
          <input type="checkbox" id="compressText">
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>Ù†Ø§Ù… Ø³Ù†Ø¯ Ø®Ø±ÙˆØ¬ÛŒ</label>
          <input type="text" id="prefix" placeholder="Ù…Ø«Ø§Ù„: [ØªØ±Ø¬Ù…Ù‡]">
        </div>
        <div>
          <label>ÙØ±Ù…Øª</label>
          <input type="text" id="suffix" placeholder="Ù…Ø«Ø§Ù„:.srt ]">
        </div>
      </div>
      <input type="text" id="introMsg" placeholder="Ù¾ÛŒØ§Ù… Ø¯Ø± Ø§Ø¨ØªØ¯Ø§">
      <input type="text" id="halfMsg" placeholder="Ù¾ÛŒØ§Ù… Ø¯Ø± ÙˆØ³Ø·">
      <input type="text" id="endMsg" placeholder="Ù¾ÛŒØ§Ù… Ø¯Ø± Ø§Ù†ØªÙ‡Ø§">
    </div>

    <div class="kpi">
      <div><span class="key">ØªØ¹Ø¯Ø§Ø¯ ÙØ§ÛŒÙ„</span><span id="kFiles" class="val">0</span></div>
      <div><span class="key">ÙˆØ¶Ø¹ÛŒØª</span><span id="kStatus" class="val">WAIT</span></div>
      <div><span class="key">Ù¾ÛŒØ´Ø±ÙØª</span><span id="kProg" class="val">0%</span></div>
    </div>
    <div id="progressBar" class="progress-bar"></div>

    <div class="hstack">
      <button id="btnTranslate" class="btn btn-primary" disabled>Ø´Ø±ÙˆØ¹ ØªØ±Ø¬Ù…Ù‡</button>
      <button id="btnDownload" class="btn btn-success" disabled>Ø¯Ø§Ù†Ù„ÙˆØ¯ ZIP</button>
    </div>
  </section>

  <section class="card">
    <div class="preview">
      <div class="pane">
        <h3> Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´</h3>
        <div class="body" id="pPreview">â€”</div>
      </div>
    </div>
    <h3> Ù„Ø§Ú¯ Ø³ÛŒØ³ØªÙ…</h3>
    <div class="log" id="log"></div>
  </section>
</main>

<footer>
  Exclusive â˜¬SHÎNâ„¢ made
</footer>

<script>
// ---------- Utils ----------
const $ = q => document.querySelector(q);
const log = (msg, cls = 'info') => {
  const p = document.createElement('p');
  p.textContent = msg;
  p.className = cls;
  $('#log').appendChild(p);
  $('#log').scrollTop = $('#log').scrollHeight;
};
const sleep = ms => new Promise(r => setTimeout(r, ms));
const LANG = { en:'English',fa:'Persian',de:'German',fr:'French',es:'Spanish',it:'Italian',ru:'Russian',ja:'Japanese',ko:'Korean',zh:'Chinese',ar:'Arabic' };
let state = { files: [], translated: [], output: [] };

// ---------- ÙØ§ÛŒÙ„ Ùˆ ZIP ----------
const readText = file => new Promise((res, rej) => {
  const reader = new FileReader();
  reader.onload = e => res({ name: file.name, text: e.target.result });
  reader.onerror = rej;
  reader.readAsText(file);
});
const extractZip = async (file) => {
  const zip = await JSZip.loadAsync(file);
  const subs = [];
  zip.forEach((path, zipEntry) => {
    if (/\.(srt|vtt|ass)$/i.test(path)) subs.push({ name: path.split('/').pop(), async text() { return { name: path.split('/').pop(), text: await zipEntry.async('string') }; } });
  });
  return Promise.all(subs.map(async s => await s.text()));
};

// ---------- Parser ----------
const parseSRT = t => {
  const blocks = t.replace(/\r/g, '').trim().split(/\n\n+/);
  const cues = []; let chars = 0;
  for (const b of blocks) {
    const l = b.split('\n');
    if (l.length >= 2) { cues.push({ type: 'srt', idx: l[0].trim(), time: l[1].trim(), text: l.slice(2).join('\n'), raw: b }); chars += cues.at(-1).text.length; }
  }
  return { cues, chars };
};
const parseVTT = t => {
  const clean = t.replace(/\r/g, '').trim();
  let i = 0; const lines = clean.split('\n');
  if (/^WEBVTT/i.test(lines[0])) i = lines[1] === '' ? 2 : 1;
  const chunks = clean.slice(lines.slice(0, i).join('\n').length).trim().split(/\n\n+/);
  const cues = []; let chars = 0;
  for (const c of chunks) {
    const l = c.split('\n');
    const start = /-->/.test(l[0]) ? 0 : 1;
    cues.push({ type: 'vtt', id: start ? l[0] : null, time: l[start], text: l.slice(start + 1).join('\n'), raw: c });
    chars += cues.at(-1).text.length;
  }
  return { cues, chars };
};
const parseASS = t => {
  const clean = t.replace(/\r/g, '');
  const events = clean.indexOf('[Events]');
  if (events < 0) return { cues: [], chars: 0, header: clean };
  const head = clean.slice(0, events + 8);
  const lines = clean.slice(events + 8).split('\n').map(l => l.trim());
  const fmtLine = lines.find(l => /^Format:/i.test(l)) || 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text';
  const fields = fmtLine.replace(/^Format:/i, '').split(',').map(s => s.trim());
  const textIdx = Math.max(fields.findIndex(f => /^Text$/i.test(f)), fields.length - 1);
  const cues = []; let chars = 0;
  for (const l of lines) {
    if (/^Dialogue:/i.test(l)) {
      const after = l.replace(/^Dialogue:\s*/i, '');
      const parts = after.split(/,(?=(?:[^\{\}]|\{[^\}]*\})*$)/);
      cues.push({ type: 'ass', meta: parts.slice(0, textIdx), text: parts.slice(textIdx).join(','), raw: l, fmtLine, head });
      chars += cues.at(-1).text.length;
    }
  }
  return { cues, chars, fmtLine, head };
};

// ---------- Build ----------
const buildSRT = (cues, texts, addBOM, delay) => {
  const adjustTime = (time, delayMs) => {
    const [h, m, s, ms] = time.split(' --> ').map(t => t.split(/[:,]/).map(Number));
    const [sh, sm, ss, sms] = ms;
    const [eh, em, es, ems] = ms;
    const startMs = (sh * 3600 + sm * 60 + ss) * 1000 + sms;
    const endMs = (eh * 3600 + em * 60 + es) * 1000 + ems;
    const newStartMs = Math.max(0, startMs + delayMs);
    const newEndMs = Math.max(newStartMs, endMs + delayMs);
    const newSh = Math.floor(newStartMs / 3600000); newStartMs %= 3600000;
    const newSm = Math.floor(newStartMs / 60000); newStartMs %= 60000;
    const newSs = Math.floor(newStartMs / 1000); const newSms = newStartMs % 1000;
    const newEh = Math.floor(newEndMs / 3600000); newEndMs %= 3600000;
    const newEm = Math.floor(newEndMs / 60000); newEndMs %= 60000;
    const newEs = Math.floor(newEndMs / 1000); const newEms = newEndMs % 1000;
    return `${newSh}:${newSm.toString().padStart(2, '0')}:${newSs.toString().padStart(2, '0')},${newSms.toString().padStart(3, '0')} --> ${newEh}:${newEm.toString().padStart(2, '0')}:${newEs.toString().padStart(2, '0')},${newEms.toString().padStart(3, '0')}`;
  };
  return (addBOM ? '\ufeff' : '') + cues.map((c, i) => {
    const newTime = adjustTime(c.time, delay * 1000);
    const text = texts[i] || c.text;
    const finalText = (text.includes('\n') ? text.split('\n').map(t => `${prefix}${t}${suffix}`).join('\n') : `${prefix}${text}${suffix}`).trim();
    return `${c.idx}\n${newTime}\n${finalText}`;
  }).join('\n\n');
};
const buildVTT = (orig, cues, texts, addBOM, delay) => {
  const header = /^WEBVTT/i.test(orig) ? orig.split(/\n\n+/)[0] : 'WEBVTT';
  const adjustTime = (time, delayMs) => {
    const [start, end] = time.split(' --> ').map(t => t.split(/[:,]/).map(Number));
    const [sh, sm, ss, sms] = start;
    const [eh, em, es, ems] = end;
    const startMs = (sh * 3600 + sm * 60 + ss) * 1000 + sms;
    const endMs = (eh * 3600 + em * 60 + es) * 1000 + ems;
    const newStartMs = Math.max(0, startMs + delayMs);
    const newEndMs = Math.max(newStartMs, endMs + delayMs);
    const newSh = Math.floor(newStartMs / 3600000); newStartMs %= 3600000;
    const newSm = Math.floor(newStartMs / 60000); newStartMs %= 60000;
    const newSs = Math.floor(newStartMs / 1000); const newSms = newStartMs % 1000;
    const newEh = Math.floor(newEndMs / 3600000); newEndMs %= 3600000;
    const newEm = Math.floor(newEndMs / 60000); newEndMs %= 60000;
    const newEs = Math.floor(newEndMs / 1000); const newEms = newEndMs % 1000;
    return `${newSh}:${newSm.toString().padStart(2, '0')}:${newSs.toString().padStart(2, '0')}.${newSms.toString().padStart(3, '0')} --> ${newEh}:${newEm.toString().padStart(2, '0')}:${newEs.toString().padStart(2, '0')}.${newEms.toString().padStart(3, '0')}`;
  };
  return (addBOM ? '\ufeff' : '') + header + '\n\n' + cues.map((c, i) => {
    const newTime = adjustTime(c.time, delay * 1000);
    const text = texts[i] || c.text;
    const finalText = (text.includes('\n') ? text.split('\n').map(t => `${prefix}${t}${suffix}`).join('\n') : `${prefix}${text}${suffix}`).trim();
    return (c.id ? c.id + '\n' : '') + `${newTime}\n${finalText}`;
  }).join('\n\n');
};
const buildASS = (orig, cues, texts, addBOM, delay) => {
  if (!cues.length) return orig;
  const before = orig.slice(0, orig.indexOf('[Events]') + 8);
  const after = orig.slice(orig.indexOf('[Events]') + 8).replace(/\r/g, '');
  const lines = after.split('\n');
  const fmtIdx = lines.findIndex(l => /^Format:/i.test(l));
  const fmtLine = fmtIdx >= 0 ? lines[fmtIdx] : 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text';
  const fields = fmtLine.replace(/^Format:/i, '').split(',').map(s => s.trim());
  const textIdx = Math.max(fields.findIndex(f => /^Text$/i.test(f)), fields.length - 1);
  let c = 0;
  const adjustTime = (time, delayMs) => {
    const [start, end] = time.split(' --> ').map(t => t.split(/[:,]/).map(Number));
    const [sh, sm, ss, sms] = start;
    const [eh, em, es, ems] = end;
    const startMs = (sh * 3600 + sm * 60 + ss) * 1000 + sms;
    const endMs = (eh * 3600 + em * 60 + es) * 1000 + ems;
    const newStartMs = Math.max(0, startMs + delayMs);
    const newEndMs = Math.max(newStartMs, endMs + delayMs);
    const newSh = Math.floor(newStartMs / 3600000); newStartMs %= 3600000;
    const newSm = Math.floor(newStartMs / 60000); newStartMs %= 60000;
    const newSs = Math.floor(newStartMs / 1000); const newSms = newStartMs % 1000;
    const newEh = Math.floor(newEndMs / 3600000); newEndMs %= 3600000;
    const newEm = Math.floor(newEndMs / 60000); newEndMs %= 60000;
    const newEs = Math.floor(newEndMs / 1000); const newEms = newEndMs % 1000;
    return `${newSh}:${newSm.toString().padStart(2, '0')}:${newSs.toString().padStart(2, '0')}.${newSms.toString().padStart(3, '0')} --> ${newEh}:${newEm.toString().padStart(2, '0')}:${newEs.toString().padStart(2, '0')}.${newEms.toString().padStart(3, '0')}`;
  };
  const rebuilt = lines.map(l => {
    if (/^Dialogue:/i.test(l)) {
      const aft = l.replace(/^Dialogue:\s*/i, '');
      const parts = aft.split(/,(?=(?:[^\{\}]|\{[^\}]*\})*$)/);
      const timePart = parts[1].split(' --> ');
      const newTime = adjustTime(parts[1], delay * 1000);
      const left = parts.slice(0, 1).concat([newTime]).concat(parts.slice(2, textIdx));
      const newText = texts[c] !== undefined ? texts[c] : parts.slice(textIdx).join(',');
      const finalText = (newText.includes('\n') ? newText.split('\n').map(t => `${prefix}${t}${suffix}`).join('\n') : `${prefix}${newText}${suffix}`).trim();
      c++;
      return 'Dialogue: ' + left.join(',') + ',' + finalText;
    }
    return l;
  }).join('\n');
  return (addBOM ? '\ufeff' : '') + before + rebuilt;
};

// ---------- Translation with â˜¬SHÎNâ„¢ Core ----------
const translateSHENCore = async (txts, src, tgt, style, intro, half, end) => {
  const stylePrompt = { colloquial: 'Ù…Ø­Ø§ÙˆØ±Ù‡â€ŒØ§ÛŒ Ùˆ Ø±ÙˆØ§Ù†', academic: 'Ø±Ø³Ù…ÛŒ Ùˆ Ø¯Ù‚ÛŒÙ‚', adult: 'Ø¨Ø¯ÙˆÙ† Ø³Ø§Ù†Ø³ÙˆØ±' }[style] || '';
  const prompt = `ØªØ±Ø¬Ù…Ù‡ Ø§Ø² ${LANG[src] || 'Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ'} Ø¨Ù‡ ${LANG[tgt]} (${stylePrompt}) Ùˆ Ø­ÙØ¸ Ø®Ø·â€ŒØ¨Ù†Ø¯ÛŒ:\n${txts.map((t, i) => `${i + 1}. ${t}`).join('\n')}${intro ? `\nØ¯Ø± Ø®Ø· 1 Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†: ${intro}` : ''}${half ? `\nØ¯Ø± Ø®Ø· ${Math.floor(txts.length / 2)} Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†: ${half}` : ''}${end ? `\nØ¯Ø± Ø¢Ø®Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†: ${end}` : ''}`;
  const res = await fetch('https://text.pollinations.ai/openai', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ messages: [{ role: 'user', content: prompt }] })
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  const raw = data.choices?.[0]?.message?.content || '';
  return raw.split(/\n+/).map(l => l.replace(/^\s*\d+\.?\s*/, '').trim()).filter(l => l).slice(0, txts.length);
};

// ---------- State ----------
const resetUI = () => {
  state = { files: [], translated: [], output: [] };
  $('#kFiles').textContent = '0';
  $('#kStatus').textContent = 'WAIT';
  $('#kProg').textContent = '0%';
  $('#progressBar').style.width = '0';
  $('#pPreview').textContent = 'â€”';
  $('#btnTranslate').disabled = true;
  $('#btnDownload').disabled = true;
  $('#log').innerHTML = '';
};

// ---------- DropZone ----------
const drop = $('#drop'), fileInput = $('#file');
['click'].forEach(e => drop.addEventListener(e, () => fileInput.click()));
['dragenter', 'dragover'].forEach(e => drop.addEventListener(e, ev => { ev.preventDefault(); drop.classList.add('drag'); }));
['dragleave', 'drop'].forEach(e => drop.addEventListener(e, ev => { ev.preventDefault(); drop.classList.remove('drag'); }));
drop.addEventListener('drop', ev => {
  const files = Array.from(ev.dataTransfer.files);
  if (files.length) handleFiles(files);
});
fileInput.addEventListener('change', ev => {
  const files = Array.from(ev.target.files);
  if (files.length) handleFiles(files);
});

const handleFiles = async (files) => {
  if (files.some(f => f.size > 10 * 1024 * 1024)) { log('[ERR] Ø­Ø¯Ø§Ú©Ø«Ø± Û±Û° Ù…Ú¯Ø§Ø¨Ø§ÛŒØª Ø¨Ø±Ø§ÛŒ Ù‡Ø± ÙØ§ÛŒÙ„', 'err'); return; }
  resetUI();
  const filePromises = files.map(file => {
    if (file.type === 'application/zip' || /\.zip$/i.test(file.name)) {
      return extractZip(file).then(subs => subs.map(s => s));
    } else {
      return readText(file).then(data => [data]);
    }
  });
  const allFiles = (await Promise.all(filePromises)).flat();
  state.files = allFiles.map(f => ({ name: f.name, ...parseSRT(f.text) })).filter(f => f.cues.length > 0);
  $('#kFiles').textContent = state.files.length;
  $('#kStatus').textContent = 'READY';
  if (state.files[0]?.cues[0]) $('#pPreview').textContent = state.files[0].cues[0].text;
  log(`[FILE] ${state.files.length} ÙØ§ÛŒÙ„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯`, 'ok');
  $('#btnTranslate').disabled = false;
};

// ---------- Ù„ÛŒÙ†Ú© Ù…Ø³ØªÙ‚ÛŒÙ… ----------
$('#btnLoadUrl').addEventListener('click', async () => {
  const url = $('#urlInput').value.trim();
  if (!url) { log('[ERR] Ù„ÛŒÙ†Ú© Ø®Ø§Ù„ÛŒ Ø§Ø³Øª', 'err'); return; }
  try {
    const u = new URL(url);
    if (!/\.(srt|vtt|ass)$/i.test(u.pathname)) { log('[ERR] Ù¾Ø³ÙˆÙ†Ø¯ Ù„ÛŒÙ†Ú© Ø¨Ø§ÛŒØ¯ srt/vtt/ass Ø¨Ø§Ø´Ø¯', 'err'); return; }
    log('[URL] Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª...', 'info');
    const res = await fetch(url);
    if (!res.ok) throw new Error(res.statusText);
    const text = await res.text();
    const name = u.pathname.split('/').pop();
    state.files = [{ name, ...parseSRT(text) }].filter(f => f.cues.length > 0);
    $('#kFiles').textContent = state.files.length;
    $('#kStatus').textContent = 'READY';
    if (state.files[0]?.cues[0]) $('#pPreview').textContent = state.files[0].cues[0].text;
    log(`[FILE] ${name} Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯`, 'ok');
    $('#btnTranslate').disabled = false;
  } catch (e) { log('[ERR] ' + e.message, 'err'); }
});

// ---------- ØªØ±Ø¬Ù…Ù‡ Ø¨Ø§ Progress ----------
$('#btnTranslate').onclick = async () => {
  if (!state.files.length) return;
  $('#btnTranslate').disabled = true;
  $('#btnDownload').disabled = true;
  log('[TRANSLATE] Ø´Ø±ÙˆØ¹ Ø¨Ø§ â˜¬SHÎNâ„¢ Core', 'info');
  try {
    const src = $('#src').value, tgt = $('#tgt').value;
    const style = $('#translationStyle').value;
    const intro = $('#introMsg').value, half = $('#halfMsg').value, end = $('#endMsg').value;
    const delay = parseFloat($('#delay').value) || 0;
    const compress = $('#compressText').checked;
    const prefix = $('#prefix').value || '';
    const suffix = $('#suffix').value || '';
    const total = state.files.length;
    let done = 0;

    state.translated = await Promise.all(state.files.map(async file => {
      const texts = file.cues.map(c => c.text);
      const translated = await translateSHENCore(texts, src, tgt, style, intro, half, end);
      if (compress) {
        translated.forEach((t, i) => {
          const chars = t.replace(/\s+/g, ' ').trim().length;
          if (chars > 42) {
            translated[i] = t.split(' ').slice(0, Math.ceil(42 / (chars / t.split(' ').length))).join(' ') + '...';
          }
        });
      }
      if ($('#filterProfanity').checked) {
        translated = translated.map(t => t.replace(/\b(Ú©ÛŒØ±|Ú©Ø³|Ù…Ø§Ø¯Ø±Ø¬Ù†Ø¯Ù‡)\b/gi, '***'));
      }
      done++;
      const prog = Math.round((done / total) * 100);
      $('#kProg').textContent = prog + '%';
      $('#progressBar').style.width = prog + '%';
      $('#kStatus').textContent = 'TRANSLATING';
      await sleep(500);
      return { name: file.name, cues: file.cues, translated };
    }));

    state.output = state.translated.map((f, i) => {
      const file = state.files[i];
      let output;
      if (file.kind === 'srt') output = buildSRT(file.cues, f.translated, true, delay);
      else if (file.kind === 'vtt') output = buildVTT(file.raw, file.cues, f.translated, true, delay);
      else if (file.kind === 'ass') output = buildASS(file.raw, file.cues, f.translated, true, delay);
      return { name: f.name.replace(/\.[^.]+$/, '') + '_translated.' + file.kind, content: output };
    });

    if (state.output[0]?.content) $('#pPreview').textContent = state.output[0].content.split('\n\n')[0].split('\n').slice(2).join('\n');
    $('#kStatus').textContent = 'DONE';
    $('#btnDownload').disabled = false;
    log('[SUCCESS] ØªØ±Ø¬Ù…Ù‡ Ø¢Ù…Ø§Ø¯Ù‡ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ø³Øª', 'ok');
  } catch (e) {
    log('[ERR] ' + e.message, 'err');
    $('#kStatus').textContent = 'ERROR';
    $('#progressBar').style.width = '0';
  }
  $('#btnTranslate').disabled = false;
};

// ---------- Ø¯Ø§Ù†Ù„ÙˆØ¯ ----------
$('#btnDownload').onclick = async () => {
  const zip = new JSZip();
  state.output.forEach(file => zip.file(file.name, file.content));
  const blob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'translated_subtitles.zip';
  a.click();
  URL.revokeObjectURL(url);
  resetUI();
};

// ---------- init ----------
resetUI();
</script>
</body>
</html>
